// Generated by CoffeeScript 1.3.3
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(function(require) {
  var EventDispatcher, Layout, NodeEvent;
  EventDispatcher = require("../events/helpers/EventDispatcher");
  NodeEvent = require("../events/NodeEvent");
  return Layout = (function(_super) {

    __extends(Layout, _super);

    function Layout() {
      Layout.__super__.constructor.call(this);
      this.size = 0;
      this.nodes = [];
    }

    Layout.prototype.addToLayout = function(object, moveToCoordinates) {
      /*
      */
      throw 'Method must be overriden by child class';
    };

    Layout.prototype.addNode = function(object, moveToCoordinates) {
      /*
      */
      throw 'Method must be overriden by child class';
    };

    Layout.prototype.addNodes = function(nodes) {
      /* Adds a specified number of empty nodes to the layout
      */

      var n, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        n = nodes[_i];
        _results.push(this.addNode(n));
      }
      return _results;
    };

    Layout.prototype.toString = function() {
      return "[object Layout]";
    };

    Layout.prototype.toJSON = function() {
      /*  Serializes the layout data of each node as a JSON string. Includes the 'type', 'size' and 'nodes' properties.
      */

      var i, nodes, _i, _ref;
      for (i = _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        nodes = this.nodes[i].toObject();
      }
      return {
        type: this.toString(),
        size: this.size,
        nodes: nodes
      };
    };

    Layout.prototype.getNodeByLink = function(link) {
      /* Returns node object by specified display object
      */

      var node, _i, _len, _ref;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.getLink() === link) {
          return node;
        }
      }
      return null;
    };

    Layout.prototype.getNodeIndex = function(node) {
      /* Returns specified node object's index in the collection
      */
      return this.nodes.indexOf(node);
    };

    Layout.prototype.getNodeAt = function(index) {
      /* Returns node object at specified index of collection
      */
      return this.nodes[index];
    };

    Layout.prototype.linkExists = function(link) {
      /* Returns true if a link (DisplayObject owned by a layout's node) exists in the layout
      */

      var node, _i, _len, _ref;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (link === node.getLink()) {
          return true;
        }
      }
      return false;
    };

    Layout.prototype.swapNodeLinks = function(nodeTo, nodeFrom) {
      /* Swaps links of two node objects
      */

      var tmpLink;
      tmpLink = nodeTo.getLink();
      nodeTo.setLink(nodeFrom.getLink());
      nodeFrom.setLink(tmpLink);
    };

    Layout.prototype.removeLinks = function() {
      /* Removes all links between nodes and display objects
      */

      var node, _i, _len, _ref;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        node.setLink(null);
      }
    };

    Layout.prototype.removeLinkAt = function(index) {
      /* Removed the link between the node and display object at the specified index
      */
      return this.nodes[index].setLink(null);
    };

    Layout.prototype.removeNode = function(node) {
      var removedNode;
      removedNode = this.nodes.splice(this.getNodeIndex(node), 1)[0];
      this.dispatchEvent(new NodeEvent(NodeEvent.prototype.REMOVE, removedNode));
      return --this.size;
    };

    Layout.prototype.removeAllNodes = function() {
      /* Removes all nodes from the layout
      */
      this.nodes = [];
      return this.size = 0;
    };

    Layout.prototype.removeNodeByLink = function(link) {
      /* Removes the node that is linked to the specified object
      */

      var node, _i, _len, _ref;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.getLink() === link) {
          this.removeNode(node);
          return;
        }
      }
    };

    Layout.prototype.addLinkAt = function(link, index) {
      /* Adds a link between the specified display object to the node object at the specified index
      */
      return this.nodes[index].setLink(link);
    };

    Layout.prototype.storeNode = function(node) {
      if (!this.nodes) {
        this.nodes = [];
      }
      this.nodes.push(node);
      return ++this.size;
    };

    Layout.prototype.storeNodeAt = function(node, index) {
      if (!this.nodes) {
        this.nodes = [];
      }
      this.nodes.splice(index, 0, node);
      return ++this.size;
    };

    Layout.prototype.getNextAvailableNode = function() {
      var node, _i, _len, _ref;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.getLink() !== null) {
          return node;
        }
      }
    };

    return Layout;

  })(EventDispatcher);
});
