   module coordinate.layouts.threedee {	import threedee =  coordinate.ants.LayoutType;	import coordinate.events.CoordyNodeEvent;	import coordinate.nodes.INode;	import coordinate.nodes.threedee.EllipseNode3d;	import coordinate.nodes.threedee ;	export class WaveEllipse3d extends Layout3d implements ILayout3d	{				private static  PI:Number=Math.PI;		private static  PI_180:Number=Math.PI/180;				 _rotationY:Number;		 _rotationZ:Number;				 _frequencyX:Number=1;		 _frequencyY:Number=1;		 _frequencyZ:Number=1;						 get eccentricity():Number		{			var a:Number = (_width>_height) ? _width/2:_height/2;			var b:Number = (_width>_height) ? _height/2:_width/2;			var e:Number = Math.sqrt(1-(Math.pow(b,2)/Math.pow(a,2)));						return e;		}						 set frequencyX(value:Number):void		{			this._frequencyX=value;			this._updateFunction();		}				 get frequencyX():Number { return this._frequencyX; }						 set frequencyY(value:Number):void		{			this._frequencyY=value;			this._updateFunction();		}				 get frequencyY():Number { return this._frequencyY; }						 set frequencyZ(value:Number):void		{			this._frequencyZ=value;			this._updateFunction();		}				 get frequencyZ():Number { return this._frequencyZ; }						 set rotationX(value:Number):void		{			this._rotation=value;			this._updateFunction();		}				 get rotationX():Number { return this._rotation; }						 set rotationY(value:Number):void		{			this._rotationY=value;			this._updateFunction();		}				 get rotationY():Number { return this._rotationY; }						 set rotationZ(value:Number):void		{			this._rotationZ=value;			this._updateFunction();		}				 get rotationZ():Number { return this._rotationZ; }								 WaveEllipse3d(width:Number, 									height:Number, 									depth:Number, 									x:Number=0, 									y:Number=0, 									z:Number=0, 									rotation:Number=0, 									rotationY:Number=90, 									rotationZ:Number=90, 									jitterX:Number=0, 									jitterY:Number=0, 									jitterZ:Number=0):void		{				this._nodes = new Array();			this._width=width;			this._height=height;			this._depth=depth;			this._x=x;			this._y=y;			this._z=z;			this._jitterX=jitterX;			this._jitterY=jitterY;			this._jitterZ=jitterZ;			this._rotation=rotation;			this._rotationY=rotationY;			this._rotationZ=rotationZ;		}						  toString():String { return LayoutType.WAVE_ELLIPSE_3D; }						  addNode(object:any=null, moveToCoordinates:boolean=true):INode		{			if(object&&!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "z", "rotationX", "rotationY", "rotationZ"');			if(object&&linkExists(object)) return null;			var node:EllipseNode3d = new EllipseNode3d(object,0,0,0,0,Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)));			this.storeNode(node);						this.update();						if(object&&moveToCoordinates) this.render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}								  addToLayout(object:any,  moveToCoordinates:boolean=true):INode		{			if(!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "z", "rotationX", "rotationY", "rotationZ"');			if(linkExists(object)) return null;			var node:EllipseNode3d = new EllipseNode3d(object,0,0,0,0,Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)));			this.storeNode(node);						this.update();						if(moveToCoordinates) this.render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}						 getCellAngle(cell:threedee.INode3d):Number		{			var xR:Number = cell.link.x-(_x+_width/2);			var yR:Number = cell.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			var a:Number = rads*(180/PI)+90;						return a;		}						 setCellAngle(cell:threedee.INode3d, angle:Number):void		{			var nAngle:Number = getCellAngle(cell);			this.rotation=this.rotation-angle-nAngle;		}						  clone():ILayout3d		{			var we3d:WaveEllipse3d = new WaveEllipse3d(_width, _height, _depth, _x, _y, _z, _rotation, _rotationY, _rotationZ, _jitterX, _jitterY, _jitterZ);					we3d.frequencyX=this._frequencyX;			we3d.frequencyY=this._frequencyY;			we3d.frequencyZ=this._frequencyZ;						return we3d;		}								  update():void		{			var w:Number = this._width/2;			var h:Number = this._height/2;			var rOffset:Number = _rotation*(PI_180);			var rad:Number;			var c:EllipseNode3d;						_depth=0;						var rY:Number = this._rotationY*(PI/180);			var rZ:Number = this._rotationZ*(PI/180);						for(var i:Number=0; i<this._size; i++)			{									c = this._nodes[i];				rad = ((PI*(i))/(this._size/2))+rOffset;								c.x = (Math.sin(rZ)*(w*Math.cos(rad*this._frequencyX)))+(_x)+(c.jitterX*this._jitterX);				c.y= (Math.cos(rY)*(h*Math.sin(rad*this._frequencyY)))-(Math.cos(rZ)*(h*Math.cos(rad)))+(this._y)+(c.jitterY*this._jitterY);				c.z=  (Math.sin(rY)*(h*Math.sin(rad*this._frequencyZ))+(_z))+(c.jitterZ*this._jitterZ);							}		}							 rotateCellToTop(cell:threedee.INode3d):Number		{			var xR:Number = cell.link.x-(_x+_width/2);			var yR:Number = cell.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			//rotation of individual object			var a = rads*(180/PI)+90;						this.rotation=rotation-a;			return a;		}	}}