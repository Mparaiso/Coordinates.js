    module coordinate.layouts.threedee {	import threedee =  coordinate.ants.LayoutType;	import coordinate.events.CoordyNodeEvent;	import coordinate.nodes.INode;	import coordinate.nodes.threedee.EllipseNode3d;	import coordinate.nodes.threedee ;	export class Ellipse3d extends Layout3d implements ILayout3d	{		public static  UPDATE_FAST:string="updateFast";		public static  UPDATE_ACCURATE:string="updateAccurate";				private static  PI:Number=Math.PI;		private static  PI_180:Number=PI/180;				 _rotationY:Number;		 _rotationZ:Number;				 _updateType:string;									  get depth():Number { return _height; }		  set depth(value:Number):void 		{			_height=value;			_updateFunction();		}								 get updateType():String { return this._updateType; }			 set updateType(value:string):void		{			this._updateType=value;		}						 get eccentricity():Number		{			var a:Number = (_width>_height) ? _width/2:_height/2;			var b:Number = (_width>_height) ? _height/2:_width/2;			var e:Number = Math.sqrt(1-(Math.pow(b,2)/Math.pow(a,2)));						return e;		}						  get rotation():Number { return this._rotation; } 		  set rotation(value:Number):void		{			this._rotation=value;			this._updateFunction();		}						 get rotationX():Number { return this._rotation; } 		 set rotationX(value:Number):void		{			this._rotation=value;			this._updateFunction();		}						 get rotationY():Number { return this._rotationY; }		 set rotationY(value:Number):void		{			this._rotationY=value;			this._updateFunction();		}						 get rotationZ():Number { return this._rotationZ; }		 set rotationZ(value:Number):void		{			this._rotationZ=value;			this._updateFunction();		}										 Ellipse3d(width:Number, 								height:Number, 								x:Number=0, 								y:Number=0, 								z:Number=0, 								rotation:Number=0, 								rotationY:Number=0, 								rotationZ:Number=0, 								jitterX:Number=0, 								jitterY:Number=0, 								jitterZ:Number=0):void		{						this._width=width;			this._height=height;			this._x=x;			this._y=y;			this._z=z;			this._jitterX=jitterX;			this._jitterY=jitterY;			this._jitterZ=jitterZ;			this._rotation=rotation;			this._rotationY=rotationY;			this._rotationZ=rotationZ;			this._updateType=UPDATE_ACCURATE;					}								  toString():String { return LayoutType.ELLIPSE_3D; }						  addNode(object:any=null, moveToCoordinates:boolean=true):INode		{			if(object&&!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "z", "rotationX", "rotationY", "rotationZ"');			if(object&&linkExists(object)) return null;			var node:EllipseNode3d = new EllipseNode3d(object,0,0,0,0,0,0,Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)));			this.storeNode(node);						this.update();						if(object&&moveToCoordinates) render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}						  addToLayout(object:any,  moveToCoordinates:boolean=true):INode		{			if(!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "z", "rotationX", "rotationY", "rotationZ"');			if(linkExists(object)) return null;			var node:EllipseNode3d = new EllipseNode3d(object,0,0,0,0,0,0,Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)));			this.storeNode(<EllipseNode3d>node);						this.update();						if(moveToCoordinates) this.render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}						 getNodeAngle(node:threedee.INode3d):Number		{			var xR:Number = node.link.x-(_x+_width/2);			var yR:Number = node.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			var a:Number = rads*(180/PI)+90;						return a;		}						 setNodeAngle(node:threedee.INode3d):void		{			var angle:Number = getNodeAngle(node);			this.rotation=this.rotation-angle;		}						  clone():ILayout3d		{			return new Ellipse3d(_width, _height, _x, _y, _z, _rotation, _rotationY, _rotationZ, _jitterX, _jitterY, _jitterZ);		}								  update():void		{			(this._updateType==UPDATE_ACCURATE)?update_accurate():update_fast();		}						 update_fast():void		{			var len:Number=this._size;			var rOffset:Number = _rotation*PI_180;			var halfLen:Number=len >> 1;			var w:Number = this._width/2;			var h:Number = this._height/2;			var rad:Number;			var c:EllipseNode3d;			var i:Number=0;						_depth=0;						var rZ:Number=_rotationZ*PI_180;			var rY:Number=_rotationY*PI_180;			var rZ2:Number=rZ + 1.57079632;			var rY2:Number=rY + 1.57079632;						var sRZ:Number;			var sRY:Number;						var cRZ:Number;			var cRY:Number;			var cRad:Number;			var sRad:Number;						//rotZ			if (rZ > 6.28318531 || rZ < -6.28318531) rad = (rZ % 6.28318531);		    if (rZ < -3.14159265)  rZ += 6.28318531;		    else if (rZ > 3.14159265)  rZ -= 6.28318531;						if (rZ < 0) sRZ = 1.27323954 * rZ + .405284735 * rZ * rZ;			else  sRZ = 1.27323954 * rZ - 0.405284735 * rZ * rZ;			if (rZ2 >  3.14159265) rZ2 -= 6.28318531;			if (rZ2 < 0) cRZ = 1.27323954 * rZ2 + 0.405284735 * rZ2 * rZ2;			else cRZ = 1.27323954 * rZ2 - 0.405284735 * rZ2 * rZ2;						//rotY			if (rY > 6.28318531 || rY < -6.28318531) rY = (rY % 6.28318531);		    if (rY < -3.14159265)  rY += 6.28318531;		    else if (rY > 3.14159265)  rY -= 6.28318531;						if (rY < 0) sRY = 1.27323954 * rY + .405284735 * rY * rY;			else  sRY = 1.27323954 * rY - 0.405284735 * rY * rY;			if (rY2 >  3.14159265) rY2 -= 6.28318531;			if (rY2 < 0) cRY = 1.27323954 * rY2 + 0.405284735 * rY2 * rY2;			else cRY = 1.27323954 * rY2 - 0.405284735 * rY2 * rY2;						for(i=0; i<len; i++)			{					c = this._nodes[i] as EllipseNode3d;				rad = ((PI*(i))/(halfLen))+rOffset;								if (rad > 6.28318531 || rad < -6.28318531) rad = (rad % 6.28318531);			    if (rad < -3.14159265)  rad += 6.28318531;			    else if (rad > 3.14159265)  rad -= 6.28318531;								if (rad < 0) sRad = 1.27323954 * rad + .405284735 * rad * rad;				else  sRad = 1.27323954 * rad - 0.405284735 * rad * rad;			    rad += 1.57079632;				if (rad >  3.14159265) rad -= 6.28318531;				if (rad < 0) cRad = 1.27323954 * rad + 0.405284735 * rad * rad;				else cRad = 1.27323954 * rad - 0.405284735 * rad * rad;													c.x = (sRZ*(w*cRad))+(_x)+(c.jitterX*this._jitterX);				c.y= (cRY*(h*sRad))-(cRZ*(h*cRad))+(_y)+(c.jitterY*this._jitterY);				c.z=  (sRY*(h*sRad)+(_z))+(c.jitterZ*this._jitterZ);							}		}						 update_accurate():void		{			var len:Number=this._size;			var w:Number = this._width/2;			var h:Number = this._height/2;			var rOffset:Number = _rotation*(PI/180);			var rad:Number;			var c:EllipseNode3d;						_depth=0;						var rY:Number = (90+this._rotationY)*(PI/180);			var rZ:Number = (90+this._rotationZ)*(PI/180);						for(var i:Number=0; i<len; i++)			{									c = this._nodes[i];				rad = ((PI*(i))/(len/2))+rOffset;								c.x= (Math.sin(rZ)*(w*Math.cos(rad)))+(_x)+(c.jitterX*this._jitterX);				c.y= (Math.cos(rY)*(h*Math.sin(rad)))-(Math.cos(rZ)*(h*Math.cos(rad)))+(this._y)+(c.jitterY*this._jitterY);				c.z= (Math.sin(rY)*(h*Math.sin(rad))+(_z))+(c.jitterZ*this._jitterZ);								//need to add option to register ellipse layout at center... 							}		}								 rotateCellToTop(cell:threedee.INode3d):Number		{			var xR:Number = cell.link.x-(_x+_width/2);			var yR:Number = cell.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			//rotation of individual object			var a = rads*(180/PI)+90;						this.rotation=rotation-a;			return a;		}	}}