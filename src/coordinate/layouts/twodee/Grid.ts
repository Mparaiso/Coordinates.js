    module coordinate.layouts.twodee {	import geom =  coordinate.ants.GridLayoutDirection;	import coordinate.ants.LayoutType;	import coordinate.events.CoordyNodeEvent;	import coordinate.nodes.INode;	import coordinate.nodes.twodee.GridNode;		import flash.geom ;	export class Grid extends Layout2d implements ILayout2d	{		 _rows:Number;		 _columns:Number;		 _hPadding:Number=0;		 _yPadding:Number=0;				 _hDirection:string;		 _vDirection:string;		 _maxNodes:Number;						 get columns():uint { return _columns; }						 get rows():int { return _rows; }									 get horizonalDirection():String { return _hDirection; }		 set horizonalDirection(value:string):void		{			this._hDirection=value;			this._updateFunction();		}								 get verticalDirection():String { return _vDirection; }		 set verticalDirection(value:string):void		{			this._vDirection=value;			this._updateFunction();		}						 get paddingX():Number { return this._hPadding; }		 set paddingX(value:Number):void		{			this._hPadding=value;			this._updateFunction();		}						 get paddingY():Number { return this._yPadding; }		 set paddingY(value:Number):void		{			this._yPadding=value;			this._updateFunction();		}						 get nodeWidth():Number { return _width/_columns; }						 get nodeHeight():Number { return _height/_rows; }								 Grid(width:Number, 							height:Number, 							columns:Number, 							rows:Number, 							hPadding:Number=0, 							vPadding:Number=0, 							x:Number=0, 							y:Number=0, 							jitterX:Number=0, 							jitterY:Number=0):void		{			this._width=width;			this._height=height;			this._rows=rows;			this._columns=columns;			this._maxNodes=_rows*_columns;			this._hPadding=hPadding;			this._yPadding=vPadding;			this._x=x;			this._y=y;			this._jitterX=jitterX;			this._jitterY=jitterY;		}						  toString():String { return LayoutType.GRID; }						 getColumn(column:Number):Array		{			var c:Array = new Array();			for(var i:Number=0; i<_rows; i++)			{				c.push(_nodes[(i*_columns)+column]);			}			return c;		}						 getRow(row:Number):Array		{			var c:Array = new Array();			for(var i:Number=row*_columns; i<(row*_columns)+_columns; i++)			{				c.push(_nodes[i]);			}			return c;		}						 removeItemAt(column:Number, row:Number):void		{			this.getNodeFromCoordinates(column, row).link=null;		}						 addItemAt(object:any, column:Number, row:Number, moveToCoordinates:boolean=true):INode		{			if(!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "rotation"');			if(linkExists(object)) return null;			var node:GridNode = this.getNodeFromCoordinates(column, row);			node.link=object;			if(moveToCoordinates)			{				object.x=node.x;				object.y=node.y;			}			return node;		}						 getNodeFromCoordinates(column:Number, row:Number):GridNode		{			return this._nodes[(row*_columns)+column];		}						  addNode(object:any=null, moveToCoordinates:boolean=true):INode		{						if(object&&!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "rotation"');			if(object&&linkExists(object)||_size>=_maxNodes) return null;						var d:geom.Rectangle = this.calculateCellSize();			var c:int = _size%_columns;			var r:int = Math.floor(_size/(_maxNodes/_rows));			var node:GridNode = new GridNode(object, c,r,((d.width*c)+(c*_hPadding)+_x),((d.height*r)+(r*_yPadding)+_y));						storeNode(node);						if(object&&moveToCoordinates) object.x=node.x, object.y=node.y;						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}				  addNodes(count:Number):void {}						  addToLayout(object:any, moveToCoordinates:boolean=true):INode		{			if(!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "rotation"');			if(object&&linkExists(object)||_size>=_maxNodes) return null;						var d:geom.Rectangle = this.calculateCellSize();			var c:int = _size%_columns;			var r:int = Math.floor(_size/(_maxNodes/_rows));			var node:GridNode = new GridNode(object, c,r,((d.width*c)+(c*_hPadding)+_x),((d.height*r)+(r*_yPadding)+_y));						storeNode(node);			if(moveToCoordinates) object.x=node.x, object.y=node.y;						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}						  clone():ILayout2d		{			return new Grid(_width, _height, _columns, _rows, paddingX, paddingY, _x, _y, _jitterX, _jitterY);		}							  update():void		{			var total:uint = _columns*_rows;			var d:geom.Rectangle = this.calculateCellSize();			var c:Number;			var r:Number;			var node:GridNode;			for(var i=0; i<_size; i++)			{				node = this._nodes[i];				if(!node) break;								c = i%_columns;				r = Math.floor(i/(total/_rows));								if(_hDirection==GridLayoutDirection.RIGHT_TO_LEFT) c=(_columns-1)-c;				if(_vDirection==GridLayoutDirection.BOTTOM_TO_TOP) r=(_rows-1)-r;												node.x = ((d.width*c)+(c*_hPadding)+_x);				node.y = ((d.height*r)+(r*_yPadding)+_y);			}		}								 calculateCellSize():geom.Rectangle		{			return new geom.Rectangle(0, 0, (_width-((_columns-1)*_hPadding))/_columns, (_height-((_rows-1)*_yPadding))/_rows);		}	}}