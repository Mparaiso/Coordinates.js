   module coordinate.layouts.twodee {	import twodee =  coordinate.ants.LayoutType;	import coordinate.ants.PathAlignType;	import coordinate.events.CoordyNodeEvent;	import coordinate.nodes.INode;	import coordinate.nodes.twodee.EllipseNode;	import coordinate.nodes.twodee ;		import flash.display.*;	export class Ellipse extends Layout2d implements ILayout2d	{				private static  PI:Number=Math.PI;		 _alignType:string;		 _alignAngleOffset:Number;								 get alignAngleOffset():Number { return this._alignAngleOffset; }		 set alignAngleOffset(value:Number):void		{			this._alignAngleOffset=value;			this._updateFunction();		}								 get alignType():String { return this._alignType; }		 set alignType(value:string):void		{			this._alignType=value;			this._updateFunction();		}						 get eccentricity():Number		{			var a:Number = (_width>_height) ? _width/2:_height/2;			var b:Number = (_width>_height) ? _height/2:_width/2;			var e:Number = Math.sqrt(1-(Math.pow(b,2)/Math.pow(a,2)));						return e;		}								 Ellipse(width:Number, 								height:Number, 								x:Number=0, 								y:Number=0, 								rotation:Number=0, 								jitterX:Number=0, 								jitterY:Number=0, 								alignType:string=PathAlignType.NONE, 								alignOffset:Number=0):void		{			this._width=width;			this._height=height;			this._x=x;			this._y=y;			this._jitterX=jitterX;			this._jitterY=jitterY;			this._rotation=rotation;			this._alignType=alignType;			this._alignAngleOffset=alignOffset;		}						  toString():String { return LayoutType.ELLIPSE; }						  addNode(object:any=null, moveToCoordinates:boolean=true):INode		{			if(object&&!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "z", "rotationX", "rotationY", "rotationZ"');			if(object&&linkExists(object)) return null;			var node:EllipseNode = new EllipseNode(object,0,0,0,((Math.random()>.5)?-1:1)*Math.random(),((Math.random()>.5)?-1:1)*Math.random());			this.storeNode(node);						this.update();						if(object&&moveToCoordinates) this.render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}						  addToLayout(object:any, moveToCoordinates:boolean=true):INode		{			if(!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "rotation"');			if(linkExists(object)) return null;			var node:EllipseNode = new EllipseNode(object,0,0,0,((Math.random()>.5)?-1:1)*Math.random(),((Math.random()>.5)?-1:1)*Math.random());			this.storeNode(node);						this.update();						if(moveToCoordinates) this.render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}							  renderNode(node:twodee.INode2d):void		{			super.renderNode(node);			node.link.rotation=node.rotation;		}						  render():void		{			var c:EllipseNode;			for(var i:Number=0; i<this._size; i++)			{				c=this._nodes[i];				if(!c.link) continue;				c.link.x=c.x;				c.link.y=c.y;				c.link.rotation=(_alignType==PathAlignType.NONE)?0:c.rotation;			}		}						 getCellAngle(cell:twodee.INode2d):Number		{			var xR:Number = cell.link.x-(_x+_width/2);			var yR:Number = cell.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			var a:Number = rads*(180/PI)+90;						return a;		}						 setNodeAngle(node:twodee.INode2d, angle:Number):void		{			var nAngle:Number = getCellAngle(node);			this.rotation=this.rotation-nAngle-angle;		}						  clone():ILayout2d		{			return new Ellipse(_width, _height, _x, _y, _rotation, _jitterX, _jitterY, _alignType, _alignAngleOffset);		}							  update():void		{			var w:Number = this._width/2;			var h:Number = this._height/2;			var rOffset:Number = _rotation*(PI/180);			var rad:Number;			var c:EllipseNode;						for(var i:Number=0; i<this._size; i++)			{					c = this._nodes[i];				rad = ((PI*(i))/(this._size/2))+rOffset;												c.x = (w*Math.cos(rad))+(w+_x)+(c.jitterX*this._jitterX)-w;				c.y = (h*Math.sin(rad))+(h+_y)+(c.jitterY*this._jitterY)-h;				c.rotation = Math.atan2((_y)-c.y, (_x)-c.x)*(180/PI);				if(this._alignType==PathAlignType.ALIGN_PERPENDICULAR) c.rotation+=90; 				c.rotation+=this._alignAngleOffset;							}		}						 rotateCellToTop(cell:twodee.INode2d):Number		{			var xR:Number = cell.link.x-(_x+_width/2);			var yR:Number = cell.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			//rotation of individual object			var a = rads*(180/PI)+90;						this.rotation=rotation-a;			return a;		}	}}