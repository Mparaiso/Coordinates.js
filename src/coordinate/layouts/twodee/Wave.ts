  module coordinate.layouts.twodee {	import twodee =  coordinate.ants.LayoutType;	import coordinate.ants.PathAlignType;	import coordinate.ants.WaveFunction;	import coordinate.events.CoordyNodeEvent;	import coordinate.nodes.INode;	import coordinate.nodes.twodee ;	export class Wave extends Layout2d implements ILayout2d	{		private static  PI:Number=Math.PI;				 _frequency:Number;		 _waveFunction:string;		 _function:Function=Math.sin;		 _heightMultiplier:Number=0;		 _thetaOffset:Number=0				 _alignType:string;		 _alignAngleOffset:Number;						 get thetaOffset():Number { return this._thetaOffset; }		 set thetaOffset(value:Number):void		{			this._thetaOffset=value;			this._updateFunction();		}						 get alignAngleOffset():Number { return this._alignAngleOffset; }		 set alignAngleOffset(value:Number):void		{			this._alignAngleOffset=value;			this._updateFunction();		}							 get alignType():String { return this._alignType; }		 set alignType(value:string):void		{			this._alignType=value;			this._updateFunction();		}				 get waveFunction():String { return _waveFunction; }		 set waveFunction(value:string):void		{			switch(value)			{				case WaveFunction.SINE:					_waveFunction=value;					_function=Math.sin;					break;				case WaveFunction.COSINE:					_waveFunction=value;					_function=Math.cos;					break;				case WaveFunction.TAN:					_waveFunction=value;					_function=Math.tan;					break;				case WaveFunction.ARCSINE:					_waveFunction=value;					_function=Math.asin;					break;				case WaveFunction.ARCCOSINE:					_waveFunction=value;					_function=Math.acos;					break;				case WaveFunction.ARCTAN:					_waveFunction=value;					_function=Math.atan;					break;				default:					_waveFunction=WaveFunction.SINE;					_function=Math.sin;			}			this._updateFunction();		}				 get frequency():Number { return _frequency; }		 set frequency(value:Number):void		{			this._frequency=value;			this._updateFunction();		}						 get heightMultiplier():Number { return _heightMultiplier; }		 set heightMultiplier(value:Number):void		{			this._heightMultiplier=value;			this._updateFunction();		}								 Wave(width:Number, 							height:Number, 							x:Number=0, 							y:Number=0, 							frequency:Number=1, 							waveFunction:string=WaveFunction.SINE,							jitterX:Number=0, 							jitterY:Number=0, 							alignType:string=PathAlignType.ALIGN_PERPENDICULAR, 							alignOffset:Number=0):void		{			this._width=width;			this._height=height;			this._x=x;			this._y=y;			this._jitterX=jitterX;			this._jitterY=jitterY;			this._frequency=frequency;			this.waveFunction=waveFunction;			this._alignType=alignType;			this._alignAngleOffset=alignOffset;		}						  toString():String { return LayoutType.WAVE; }						  addNode(object:any=null, moveToCoordinates:boolean=true):INode		{			if(object&&!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "z", "rotationX", "rotationY", "rotationZ"');			if(object&&linkExists(object)) return null;			var node:twodee.Node2d = new twodee.Node2d(object,0,0,((Math.random()>.5)?-1:1)*Math.random(),((Math.random()>.5)?-1:1)*Math.random());			this.storeNode(node);						this.update();						if(object&&moveToCoordinates) this.render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}						  addToLayout(object:any,  moveToCoordinates:boolean=true):INode		{			if(!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "rotation"');			if(linkExists(object)) return null;			var node:twodee.Node2d = new twodee.Node2d(object,0,0,((Math.random()>.5)?-1:1)*Math.random(),((Math.random()>.5)?-1:1)*Math.random());			this.storeNode(<INode>node);						this.update();						if(moveToCoordinates) this.render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}						  clone():ILayout2d		{			return new Wave(_width, _height, _x, _y, _frequency, _waveFunction, _jitterX, _jitterY, _alignType, _alignAngleOffset);		}						  render():void		{			var c:twodee.Node2d;			for(var i:Number=0; i<this._size; i++)			{				c=this._nodes[i];				if(!c.link) continue;				c.link.x=c.x;				c.link.y=c.y;				c.link.rotation=(this._alignType==PathAlignType.NONE)?0:c.rotation;			}		}							  update():void		{						var len:int = this._size;			var c:twodee.Node2d;			for(var i=0; i<len; i++)			{				c = this._nodes[i];				c.x = (i*(this._width/len))+_x+(c.jitterX*this._jitterX);				c.y = (_function(PI*(i+1)/(len/2)*_frequency-(_thetaOffset*PI/180))*((this._height+(_heightMultiplier*i))/2))+_y+(c.jitterY*this._jitterY);								//in future, add option to align wave to center or top by adding height/2 to all nodes' y property								if(_function==Math.sin) c.rotation = Math.cos(PI*(i+1)/(len/2)*_frequency)*180/PI;				else if(_function==Math.cos) c.rotation = Math.sin(PI*(i+1)/(len/2)*_frequency)*180/PI;				else c.rotation = 0;								if(this._alignType==PathAlignType.ALIGN_PERPENDICULAR) c.rotation+=90; 				c.rotation+=this._alignAngleOffset;			}		}				}}